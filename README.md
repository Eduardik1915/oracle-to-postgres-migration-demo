# Projekts: Migrācija no Oracle uz PostgreSQL

## Projekta apraksts

Šis ir pet-projekts, kura mērķis ir demonstrēt datu bāzes migrāciju no Oracle uz PostgreSQL.  
Projekts ietver:
Trīs savstarpēji saistītas tabulas: `customers`, `products` un `orders`.
Divas procedūras: `get_customer_orders` un `update_product_price_dynamic`.  
Fokusā ir atšķirības sintaksē, datu tipos un uzvedībā starp abām datu bāzu pārvaldības sistēmām.

---

## 📁 Failsistēma
- `oracle/` — sākotnējie Oracle SQL skripti
- `postgresql/` — migrētie PostgreSQL skripti
- `README.md` — šis fails

---

## 📊 Tabulu izmaiņas migrācijas laikā

###  🆔 ID lauka tips
 - **Oracle**: `NUMBER GENERATED BY DEFAULT AS IDENTITY`
 - **PostgreSQL**: `INTEGER GENERATED BY DEFAULT AS IDENTITY`

 **Paskaidrojums:**  PostgreSQL ar IDENTITY var izmantot tikai `SMALLINT`, `INTEGER` vai `BIGINT`. `SMALLINT` būtu par mazu priekš ID, bet `BIGINT` paredzēs ļoti lielos datu apjomiem.
 Tāpēc izvēlēts vidējais variants - `INTEGER`.

---

###  🔤 Teksta lauku tips
 - **Oracle**: `VARCHAR2`
 - **PostgreSQL**: `VARCHAR`

**Paskaidrojums:** PostgreSQL neatbalsta `VARCHAR2`, tā vietā jāizmanto `VARCHAR`. 
                   Atšķirībā no Oracle, PostgreSQL interpretē tukšu virkni (`''`) kā tukšu virkni, nevis kā `NULL`.  
                   Tāpēc gadījumos, kad lauks tiek pārbaudīts uz `NULL`, var izmantot `NULLIF(lauks, '')`, lai panāktu līdzīgu uzvedību.

---

###  🔒 UNIQUE
 - **Oracle**: `email VARCHAR2(100) UNIQUE`
 - **PostgreSQL**: `CONSTRAINT uniq_customer_email UNIQUE(email)`
 
**Paskaidrojums:** PostgreSQL atbalsta tieši tādu pašu semantiku, kā Oracle, bet tika nolemts UNIQUE CONSTRAINT izveidot atsevišķi,
                   jo tas dod lasāmu un saprotamu vārdu, kas turpmāk palīdzēs ērtāk ar to strādāt.

---

###  🕒 Datumu lauku tips
 - **Oracle**: `created_date DATE DEFAULT SYSDATE`
 - **PostgreSQL**: `created_date TIMESTAMP DEFAULT LOCALTIMESTAMP`

**Paskaidrojums:** Oracle tips `DATE` tiek aizvietots ar `TIMESTAMP`.
                   Oracle tekošā laika operators `SYSDATE` tiek aizvietots ar `LOCALTIMESTAMP`.

---

### ✅ Boolean lauku tips
 - **Oracle**: `is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0, 1))`
 - **PostgreSQL**: `is_active BOOLEAN DEFAULT TRUE`

**Paskaidrojums:** Oracle neatbalsta `BOOLEAN` tipu, bet PostgreSQL atbalsta.

---

### 🔢 Ciparu lauku tips
 - **Oracle**: `NUMBER`
 - **PostgreSQL**: `NUMERIC`

---


## 🧩 Procedūru izmaiņas migrācijas laikā

### 🔁 IN/OUT
 - **Oracle**: `Norāda pēc parametra`
 - **PostgreSQL**: `Norāda pirms parametra`

---

### 🎯 Kursora tips 
 - **Oracle**: `SYS_REFCURSOR`
 - **PostgreSQL**: `REFCURSOR`

---

### 🔍 SELECT INTO -> NOT EXISTS 
 - **Oracle**: 

 ```
 SELECT COUNT(*) INTO v_exists
 FROM customers
 WHERE customer_id = p_customer_id;

 IF v_exists = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Customer not found');
END IF;
```

 - **PostgreSQL**:

```
IF NOT EXISTS(
	SELECT 1 FROM customers WHERE customer_id = p_customer_id
) THEN
	RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P0001';
END IF;
```

**Paskaidrojums:** PostgreSQL atbalsta NOT EXISTS/EXISTS izmantošanu tieši IF kontekstā, kas padara kodu īsāku un saprotamāku. Oracle šādu iespēju nav.

---

### ⚠️ Kļūdu izsaukums
 - **Oracle**: `RAISE_APPLICATION_ERROR(-20001, 'Customer not found');`
 - **PostgreSQL**: `RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P0001';`

**Paskaidrojums:** Oracle kļūdu kodi (-20001 utt.) tiek aizstāti ar PostgreSQL lietotāja kļūdu kodiem (P0001–P9999).
                   PostgreSQL gadījumā kļūdas kods jānorāda skaidri ar USING ERRCODE.

---

### 🧠 Dinamiskie SQL
 - **Oracle**: `v_sql := 'UPDATE products SET price = :1 WHERE product_id = :2';`
 - **PostgreSQL**: `UPDATE products SET price = $1 WHERE product_id = $2`

**Paskaidrojums:** PostgreSQL lai apzīmētu parametrus, divpunktu vietā izmanto dolārzīmes.

---

### 🚀 Dinamiskie SQL palaišana
 - **Oracle**: `EXECUTE IMMEDIATE v_sql USING p_new_price, p_product_id;`
 - **PostgreSQL**: `EXECUTE v_sql USING p_new_price, p_product_id;`

**Paskaidrojums:** PostgreSQL neizmanto IMMEDIATE, vienkārši EXECUTE.

---

### 🔢 Rindu skaita iegūšana
 - **Oracle**: `SQL%ROWCOUNT`
 - **PostgreSQL**: `GET DIAGNOSTICS v_count = ROW_COUNT;`

**Paskaidrojums:** PostgreSQL ir komanda `GET DIAGNOSTICS` kura ļauj dabūt skarto rindu skaitu ar DML operācijām. 
                   GET DIAGNOSTICS — universāls mehānisms, kurš ļauj dabūt vairāk informācijas, nekā vienkārši rindu skaitu.
