# Oracle → PostgreSQL Migrācijas projekts

## Projekta apraksts

Šis ir pet-projekts, kura mērķis ir demonstrēt datu bāzes migrāciju no Oracle uz PostgreSQL.  
Projekts ietver:
Trīs savstarpēji saistītas tabulas: `customers`, `products` un `orders`.
Divas procedūras: `get_customer_orders` un `update_product_price_dynamic`.
Vienu funkciju: `get_customer_order_summary`.
Fokusā ir atšķirības sintaksē, datu tipos un uzvedībā starp abām datu bāzu pārvaldības sistēmām.

---

## Saturs / Contents

- 📁 Failsistēma
- 🔗 Atsauces uz skriptiem
- 📊 Tabulu izmaiņas
- 🧩 Procedūru un funkciju izmaiņas

---

### 📁 Failsistēma
- `oracle/` — sākotnējie Oracle SQL skripti
- `postgresql/` — migrētie PostgreSQL skripti
- `README.md` — šis fails

---

### 📂 Failu atbilstība Oracle ↔ PostgreSQL

| Funkcionalitāte                        | Oracle fails                                                   | PostgreSQL fails                                                  |
|----------------------------------------|-----------------------------------------------------------------|-------------------------------------------------------------------|
| 📦 Datu tabulas                        | [`oracle/schema`](oracle/schema.sql)                       | [`postgresql/schema.sql`](postgresql/schema.sql)                  |
| 📄 Procedūra: `get_customer_orders`    | [`oracle/procedure_get_customer_orders`](oracle/procedure_get_customer_orders.sql) | [`postgresql/procedure_get_customer_orders`](postgresql/procedure_get_customer_orders.sql) |
| 📄 Procedūra: `update_product_price_dynamic` | [`oracle/procedure_update_product_price_dynamic`](oracle/procedure_update_product_price_dynamic.sql) | [`postgresql/procedure_update_product_price_dynamic`](postgresql/procedure_update_product_price_dynamic.sql) |
| 📄 Funkcija: `get_customer_order_summary` | [`oracle/function_get_customer_order_summary`](oracle/function_get_customer_order_summary.sql) | [`postgresql/function_get_customer_order_summary`](postgresql/function_get_customer_order_summary.sql) |
| 🧪 Testēšanas skripti                  | [`oracle/test_cases`](oracle/test_cases.sql)                                            | [`postgresql/test_cases`](postgresql/test_cases.sql)         |

---

## 📊 Tabulu migrācijas izmaiņas


###  🆔 ID lauka tips
 - **Oracle**: `NUMBER GENERATED BY DEFAULT AS IDENTITY`
 - **PostgreSQL**: `INTEGER GENERATED BY DEFAULT AS IDENTITY`

 **Paskaidrojums:**  PostgreSQL ar IDENTITY var izmantot tikai `SMALLINT`, `INTEGER` vai `BIGINT`. `SMALLINT` būtu par mazu priekš ID, bet `BIGINT` paredzēs ļoti lielos datu apjomiem.
 Tāpēc izvēlēts vidējais variants - `INTEGER`.

---

###  🔤 Teksta lauku tips
 - **Oracle**: `VARCHAR2`
 - **PostgreSQL**: `VARCHAR`

**Paskaidrojums:** PostgreSQL neatbalsta `VARCHAR2`, tā vietā jāizmanto `VARCHAR`. 
                   Atšķirībā no Oracle, PostgreSQL interpretē tukšu virkni (`''`) kā tukšu virkni, nevis kā `NULL`.  
                   Tāpēc gadījumos, kad lauks tiek pārbaudīts uz `NULL`, var izmantot `NULLIF(lauks, '')`, lai panāktu līdzīgu uzvedību.

---

###  🔒 UNIQUE
 - **Oracle**: `email VARCHAR2(100) UNIQUE`
 - **PostgreSQL**: `CONSTRAINT uniq_customer_email UNIQUE(email)`
 
**Paskaidrojums:** PostgreSQL atbalsta tieši tādu pašu semantiku, kā Oracle, bet tika nolemts `UNIQUE CONSTRAINT` izveidot atsevišķi,
                   jo tas dod lasāmu un saprotamu vārdu, kas turpmāk palīdzēs ērtāk ar to strādāt.

---

###  🕒 Datumu lauku tips
 - **Oracle**: `created_date DATE DEFAULT SYSDATE`
 - **PostgreSQL**: `created_date TIMESTAMP DEFAULT LOCALTIMESTAMP`

**Paskaidrojums:** Oracle tips `DATE` tiek aizvietots ar `TIMESTAMP`.
                   Oracle tekošā laika operators `SYSDATE` tiek aizvietots ar `LOCALTIMESTAMP`.

---

### ✅ Boolean lauku tips
 - **Oracle**: `is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0, 1))`
 - **PostgreSQL**: `is_active BOOLEAN DEFAULT TRUE`

**Paskaidrojums:** Oracle neatbalsta `BOOLEAN` tipu, bet PostgreSQL atbalsta.

---

### 🔢 Ciparu lauku tips
 - **Oracle**: `NUMBER`
 - **PostgreSQL**: `NUMERIC`

---


## 🧩 Procedurālās loģikas migrācija

### 🔁 IN/OUT
 - **Oracle**: `Norāda pēc parametra nosaukuma`
 - **PostgreSQL**: `Norāda pirms parametra nosaukuma`

---

### Atgriešanas operators
 - **Oracle**: `RETURN`
 - **PostgreSQL**: `RETURNS`

---

### Teksta pārbaude uz NULL
 - **Oracle**: `IF v_summary IS NULL THEN`
 - **PostgreSQL**: `IF v_summary = '' THEN`

**Paskaidrojums:** Oracle gadījumā tukša virkne ('') tiek interpretēta kā NULL, tāpēc pietiek pārbaudīt ar IS NULL.
                   Savukārt PostgreSQL tukša virkne nav NULL, tā ir atsevišķa vērtība (''), tāpēc pārbaude jāveic tieši ar = ''.

---

### Pāreja uz jaunu rindu
 - **Oracle**: `CHR(10)`
 - **PostgreSQL**: `E'\n'`

**Paskaidrojums:** Abas datu bāzes atbalsta ASCII koda izmantošanu (CHR(10) — jaunas rindas simbols).
                   Taču PostgreSQL papildus piedāvā E'' sintaksi, kur \n ir speciāla “escape” secība, kas apzīmē jaunu rindu.

---

### 🎯 Kursora tips 
 - **Oracle**: `SYS_REFCURSOR`
 - **PostgreSQL**: `REFCURSOR`

---

### 🔍 SELECT INTO -> NOT EXISTS 
 - **Oracle**: 

 ```
 SELECT COUNT(*) INTO v_exists
 FROM customers
 WHERE customer_id = p_customer_id;

 IF v_exists = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Customer not found');
END IF;
```

 - **PostgreSQL**:

```
IF NOT EXISTS(
	SELECT 1 FROM customers WHERE customer_id = p_customer_id
) THEN
	RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P0001';
END IF;
```

**Paskaidrojums:** PostgreSQL atbalsta `NOT EXISTS/EXISTS` izmantošanu tieši IF kontekstā, kas padara kodu īsāku un saprotamāku. Oracle šādu iespēju nav.

---

### ⚠️ Kļūdu izsaukums
 - **Oracle**: `RAISE_APPLICATION_ERROR(-20001, 'Customer not found');`
 - **PostgreSQL**: `RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P0001';`

**Paskaidrojums:** Oracle kļūdu kodi (-20001 utt.) tiek aizstāti ar PostgreSQL lietotāja kļūdu kodiem (P1000–P9999).
                   PostgreSQL gadījumā kļūdas kods jānorāda skaidri ar `USING ERRCODE`.

---

### 🧠 Dinamiskie SQL
 - **Oracle**: `UPDATE products SET price = :1 WHERE product_id = :2';`
 - **PostgreSQL**: `UPDATE products SET price = $1 WHERE product_id = $2`

**Paskaidrojums:** PostgreSQL lai apzīmētu parametrus, divpunktu vietā izmanto dolārzīmes.

---

### 🚀 Dinamiskie SQL palaišana
 - **Oracle**: `EXECUTE IMMEDIATE v_sql USING p_new_price, p_product_id;`
 - **PostgreSQL**: `EXECUTE v_sql USING p_new_price, p_product_id;`

**Paskaidrojums:** PostgreSQL neizmanto `IMMEDIATE`, vienkārši EXECUTE.

---

### 🔢 Rindu skaita iegūšana
 - **Oracle**: `SQL%ROWCOUNT`
 - **PostgreSQL**: `GET DIAGNOSTICS v_count = ROW_COUNT;`

**Paskaidrojums:** PostgreSQL ir komanda `GET DIAGNOSTICS` kura ļauj dabūt skarto rindu skaitu ar DML operācijām. 
                   `GET DIAGNOSTICS` — universāls mehānisms, kurš ļauj dabūt vairāk informācijas, nekā vienkārši rindu skaitu.
