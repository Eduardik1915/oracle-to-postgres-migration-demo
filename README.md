# Oracle â†’ PostgreSQL MigrÄcijas projekts

## Projekta apraksts

Å is ir pet-projekts, kura mÄ“rÄ·is ir demonstrÄ“t datu bÄzes migrÄciju no Oracle uz PostgreSQL.  
Projekts ietver:
TrÄ«s savstarpÄ“ji saistÄ«tas tabulas: `customers`, `products` un `orders`.
Divas procedÅ«ras: `get_customer_orders` un `update_product_price_dynamic`.
Vienu funkciju: `get_customer_order_summary`.
FokusÄ ir atÅ¡Ä·irÄ«bas sintaksÄ“, datu tipos un uzvedÄ«bÄ starp abÄm datu bÄzu pÄrvaldÄ«bas sistÄ“mÄm.

---

## Saturs / Contents

- ğŸ“ FailsistÄ“ma
- ğŸ”— Atsauces uz skriptiem
- ğŸ“Š Tabulu migrÄcijas izmaiÅ†as
- ğŸ§© ProcedurÄlÄs loÄ£ikas migrÄcija

---

### ğŸ“ FailsistÄ“ma
- `oracle/` â€” sÄkotnÄ“jie Oracle SQL skripti
- `postgresql/` â€” migrÄ“tie PostgreSQL skripti
- `README.md` â€” Å¡is fails

---

### ğŸ”— Atsauces uz skriptiem

| FunkcionalitÄte                        | Oracle fails                                                   | PostgreSQL fails                                                  |
|----------------------------------------|-----------------------------------------------------------------|-------------------------------------------------------------------|
| ğŸ“¦ Datu tabulas                        | [`oracle/schema`](oracle/schema.sql)                       | [`postgresql/schema.sql`](postgresql/schema.sql)                  |
| ğŸ“„ ProcedÅ«ra: `get_customer_orders`    | [`oracle/procedure_get_customer_orders`](oracle/procedure_get_customer_orders.sql) | [`postgresql/procedure_get_customer_orders`](postgresql/procedure_get_customer_orders.sql) |
| ğŸ“„ ProcedÅ«ra: `update_product_price_dynamic` | [`oracle/procedure_update_product_price_dynamic`](oracle/procedure_update_product_price_dynamic.sql) | [`postgresql/procedure_update_product_price_dynamic`](postgresql/procedure_update_product_price_dynamic.sql) |
| ğŸ“„ Funkcija: `get_customer_order_summary` | [`oracle/function_get_customer_order_summary`](oracle/function_get_customer_order_summary.sql) | [`postgresql/function_get_customer_order_summary`](postgresql/function_get_customer_order_summary.sql) |
| ğŸ§ª TestÄ“Å¡anas skripti                  | [`oracle/test_cases`](oracle/test_cases.sql)                                            | [`postgresql/test_cases`](postgresql/test_cases.sql)         |

---

## ğŸ“Š Tabulu migrÄcijas izmaiÅ†as


###  ğŸ†” ID lauka tips
 - **Oracle**: `NUMBER GENERATED BY DEFAULT AS IDENTITY`
 - **PostgreSQL**: `INTEGER GENERATED BY DEFAULT AS IDENTITY`

 **Paskaidrojums:**  PostgreSQL ar IDENTITY var izmantot tikai `SMALLINT`, `INTEGER` vai `BIGINT`. `SMALLINT` bÅ«tu par mazu priekÅ¡ ID, bet `BIGINT` paredzÄ“ts Ä¼oti lieliem datu apjomiem.
 TÄpÄ“c izvÄ“lÄ“ts vidÄ“jais variants - `INTEGER`.

---

###  ğŸ”¤ Teksta lauku tips
 - **Oracle**: `VARCHAR2`
 - **PostgreSQL**: `VARCHAR`

**Paskaidrojums:** PostgreSQL neatbalsta `VARCHAR2`, tÄ vietÄ jÄizmanto `VARCHAR`. 
                   AtÅ¡Ä·irÄ«bÄ no Oracle, PostgreSQL interpretÄ“ tukÅ¡u virkni (`''`) kÄ tukÅ¡u virkni, nevis kÄ `NULL`.  
                   TÄpÄ“c gadÄ«jumos, kad lauks tiek pÄrbaudÄ«ts uz `NULL`, var izmantot `NULLIF(lauks, '')`, lai panÄktu lÄ«dzÄ«gu uzvedÄ«bu.

---

###  ğŸ”’ UNIQUE
 - **Oracle**: `email VARCHAR2(100) UNIQUE`
 - **PostgreSQL**: `CONSTRAINT uniq_customer_email UNIQUE(email)`
 
**Paskaidrojums:** PostgreSQL atbalsta tieÅ¡i tÄdu paÅ¡u sintaksi kÄ Oracle, bet tika nolemts `UNIQUE CONSTRAINT` izveidot atseviÅ¡Ä·i,
                   jo tas dod lasÄmu un saprotamu vÄrdu, kas turpmÄk palÄ«dzÄ“s Ä“rtÄk ar to strÄdÄt.

---

###  ğŸ•’ Datumu lauku tips
 - **Oracle**: `created_date DATE DEFAULT SYSDATE`
 - **PostgreSQL**: `created_date TIMESTAMP DEFAULT LOCALTIMESTAMP`

**Paskaidrojums:** Oracle tips DATE un PostgreSQL tips TIMESTAMP bÅ«tiski neatÅ¡Ä·iras â€” abi glabÄ datumu un laiku.
                   GalvenÄ atÅ¡Ä·irÄ«ba ir precizitÄtÄ“: Oracle DATE satur laiku lÄ«dz sekundÄ“m, bet PostgreSQL TIMESTAMP nodroÅ¡ina laiku ar mikrosekunÅ¾u precizitÄti (lÄ«dz 6 cipariem pÄ“c komata).

---

### âœ… Boolean lauku tips
 - **Oracle**: `is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0, 1))`
 - **PostgreSQL**: `is_active BOOLEAN DEFAULT TRUE`

**Paskaidrojums:** Oracle neatbalsta `BOOLEAN` tipu, bet PostgreSQL atbalsta.

---

### ğŸ”¢ Ciparu lauku tips
 - **Oracle**: `NUMBER`
 - **PostgreSQL**: `NUMERIC`

**Paskaidrojums:** Oracle tips NUMBER un PostgreSQL tips NUMERIC ir lÄ«dzvÄ“rtÄ«gi â€” abi Ä¼auj precÄ«zi uzglabÄt gan veselus, gan decimÄldaÄ¼skaitÄ¼us jebkurÄ izmÄ“rÄ.
                   TomÄ“r praksÄ“ PostgreSQL bieÅ¾i ieteicams lietot arÄ« INTEGER, BIGINT vai DECIMAL, ja skaidri zinÄms datu veids un diapazons.

---


## ğŸ§© ProcedurÄlÄs loÄ£ikas migrÄcija

### ğŸ” IN/OUT
 - **Oracle**: `p_orders OUT SYS_REFCURSOR`
 - **PostgreSQL**: `OUT p_orders SYS_REFCURSOR`

**Paskaidrojums:** Oracle IN/OUT liekas pÄ“c mainÄ«gÄ nosaukuma, bet PostgreSQL pirms.
                   PÄ“c noklusÄ“juma abi dialekti pieÅ†em, ka parametri ir IN, tÄpÄ“c IN var arÄ« neuzrÄdÄ«t.

---

### ğŸ”™ AtgrieÅ¡anas operators
 - **Oracle**: `RETURN`
 - **PostgreSQL**: `RETURNS`

**Paskaidrojums:** Abi apzÄ«mÄ“ funkcijas atgrieÅ¾amÄs vÄ“rtÄ«bas tipu.
                   AtÅ¡Ä·irÄ«ba tikai sintaksÄ“ â€” Oracle lieto vienskaitli `RETURN`, bet PostgreSQL daudzskaitli `RETURNS`.
                   No semantikas viedokÄ¼a tie darbojas identiski.

---

### ğŸ” Teksta pÄrbaude uz NULL
 - **Oracle**: `IF v_summary IS NULL THEN`
 - **PostgreSQL**: `IF v_summary = '' THEN`

**Paskaidrojums:** Oracle gadÄ«jumÄ tukÅ¡a virkne ('') tiek interpretÄ“ta kÄ NULL, tÄpÄ“c pietiek pÄrbaudÄ«t ar `IS NULL`.
                   SavukÄrt PostgreSQL tukÅ¡a virkne nav `NULL`, tÄ ir atseviÅ¡Ä·a vÄ“rtÄ«ba (''), tÄpÄ“c pÄrbaude jÄveic tieÅ¡i ar = '' vai `NULLIF()`.

---

### â†©ï¸ PÄreja uz jaunu rindu
 - **Oracle**: `CHR(10)`
 - **PostgreSQL**: `E'\n'`

**Paskaidrojums:** Abas datu bÄzes atbalsta ASCII koda izmantoÅ¡anu (CHR(10) â€” jaunas rindas simbols).
                   TaÄu PostgreSQL papildus piedÄvÄ E'' sintaksi, kur \n ir speciÄla â€œescapeâ€ secÄ«ba, kas apzÄ«mÄ“ jaunu rindu.

---

### ğŸ¯ Kursora tips 
 - **Oracle**: `SYS_REFCURSOR`
 - **PostgreSQL**: `REFCURSOR`

---

### ğŸ” SELECT INTO -> NOT EXISTS 
 - **Oracle**: 

 ```
 SELECT COUNT(*) INTO v_exists
 FROM customers
 WHERE customer_id = p_customer_id;

 IF v_exists = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Customer not found');
END IF;
```

 - **PostgreSQL**:

```
IF NOT EXISTS(
	SELECT 1 FROM customers WHERE customer_id = p_customer_id
) THEN
	RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P1000';
END IF;
```

**Paskaidrojums:** PostgreSQL atbalsta `NOT EXISTS/EXISTS` izmantoÅ¡anu tieÅ¡i IF kontekstÄ, kas padara kodu Ä«sÄku un saprotamÄku. Oracle Å¡Ädu iespÄ“ju nav.

---

### âš ï¸ KÄ¼Å«du izsaukums
 - **Oracle**: `RAISE_APPLICATION_ERROR(-20001, 'Customer not found');`
 - **PostgreSQL**: `RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P1000';`

**Paskaidrojums:** Oracle kÄ¼Å«du kodi (-20001 utt.) tiek aizstÄti ar PostgreSQL lietotÄja kÄ¼Å«du kodiem (P1000â€“P9999).
                   PostgreSQL gadÄ«jumÄ kÄ¼Å«das kods jÄnorÄda skaidri ar `USING ERRCODE`.

---

### ğŸ§  Dinamiskie SQL
 - **Oracle**: `UPDATE products SET price = :1 WHERE product_id = :2';`
 - **PostgreSQL**: `UPDATE products SET price = $1 WHERE product_id = $2`

**Paskaidrojums:** PostgreSQL lai apzÄ«mÄ“tu parametrus, divpunktu vietÄ izmanto dolÄrzÄ«mes.

---

### ğŸš€ Dinamiskie SQL palaiÅ¡ana
 - **Oracle**: `EXECUTE IMMEDIATE v_sql USING p_new_price, p_product_id;`
 - **PostgreSQL**: `EXECUTE v_sql USING p_new_price, p_product_id;`

**Paskaidrojums:** PostgreSQL neizmanto `IMMEDIATE`, vienkÄrÅ¡i `EXECUTE`.

---

### ğŸ”¢ Rindu skaita iegÅ«Å¡ana
 - **Oracle**: `SQL%ROWCOUNT`
 - **PostgreSQL**: `GET DIAGNOSTICS v_count = ROW_COUNT;`

**Paskaidrojums:** PostgreSQL ir komanda `GET DIAGNOSTICS` kura Ä¼auj dabÅ«t skarto rindu skaitu ar DML operÄcijÄm. 
                   `GET DIAGNOSTICS` â€” universÄls mehÄnisms, kurÅ¡ Ä¼auj dabÅ«t vairÄk informÄcijas, nekÄ vienkÄrÅ¡i rindu skaitu.
