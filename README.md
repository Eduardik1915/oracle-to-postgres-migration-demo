# Oracle â†’ PostgreSQL MigrÄcijas projekts

## Projekta apraksts

Å is ir pet-projekts, kura mÄ“rÄ·is ir demonstrÄ“t datu bÄzes migrÄciju no Oracle uz PostgreSQL.  
Projekts ietver:
TrÄ«s savstarpÄ“ji saistÄ«tas tabulas: `customers`, `products` un `orders`.
Divas procedÅ«ras: `get_customer_orders` un `update_product_price_dynamic`.
Vienu funkciju: `get_customer_order_summary`.
FokusÄ ir atÅ¡Ä·irÄ«bas sintaksÄ“, datu tipos un uzvedÄ«bÄ starp abÄm datu bÄzu pÄrvaldÄ«bas sistÄ“mÄm.

---

## Saturs / Contents

- ğŸ“ FailsistÄ“ma
- ğŸ”— Atsauces uz skriptiem
- ğŸ“Š Tabulu izmaiÅ†as
- ğŸ§© ProcedÅ«ru un funkciju izmaiÅ†as

---

### ğŸ“ FailsistÄ“ma
- `oracle/` â€” sÄkotnÄ“jie Oracle SQL skripti
- `postgresql/` â€” migrÄ“tie PostgreSQL skripti
- `README.md` â€” Å¡is fails

---

### ğŸ“‚ Failu atbilstÄ«ba Oracle â†” PostgreSQL

| FunkcionalitÄte                        | Oracle fails                                                   | PostgreSQL fails                                                  |
|----------------------------------------|-----------------------------------------------------------------|-------------------------------------------------------------------|
| ğŸ“¦ Datu tabulas                        | [`oracle/schema`](oracle/schema.sql)                       | [`postgresql/schema.sql`](postgresql/schema.sql)                  |
| ğŸ“„ ProcedÅ«ra: `get_customer_orders`    | [`oracle/procedure_get_customer_orders`](oracle/procedure_get_customer_orders.sql) | [`postgresql/procedure_get_customer_orders`](postgresql/procedure_get_customer_orders.sql) |
| ğŸ“„ ProcedÅ«ra: `update_product_price_dynamic` | [`oracle/procedure_update_product_price_dynamic`](oracle/procedure_update_product_price_dynamic.sql) | [`postgresql/procedure_update_product_price_dynamic`](postgresql/procedure_update_product_price_dynamic.sql) |
| ğŸ“„ Funkcija: `get_customer_order_summary` | [`oracle/function_get_customer_order_summary`](oracle/function_get_customer_order_summary.sql) | [`postgresql/function_get_customer_order_summary`](postgresql/function_get_customer_order_summary.sql) |
| ğŸ§ª TestÄ“Å¡anas skripti                  | [`oracle/test_cases`](oracle/test_cases.sql)                                            | [`postgresql/test_cases`](postgresql/test_cases.sql)         |

---

## ğŸ“Š Tabulu migrÄcijas izmaiÅ†as


###  ğŸ†” ID lauka tips
 - **Oracle**: `NUMBER GENERATED BY DEFAULT AS IDENTITY`
 - **PostgreSQL**: `INTEGER GENERATED BY DEFAULT AS IDENTITY`

 **Paskaidrojums:**  PostgreSQL ar IDENTITY var izmantot tikai `SMALLINT`, `INTEGER` vai `BIGINT`. `SMALLINT` bÅ«tu par mazu priekÅ¡ ID, bet `BIGINT` paredzÄ“s Ä¼oti lielos datu apjomiem.
 TÄpÄ“c izvÄ“lÄ“ts vidÄ“jais variants - `INTEGER`.

---

###  ğŸ”¤ Teksta lauku tips
 - **Oracle**: `VARCHAR2`
 - **PostgreSQL**: `VARCHAR`

**Paskaidrojums:** PostgreSQL neatbalsta `VARCHAR2`, tÄ vietÄ jÄizmanto `VARCHAR`. 
                   AtÅ¡Ä·irÄ«bÄ no Oracle, PostgreSQL interpretÄ“ tukÅ¡u virkni (`''`) kÄ tukÅ¡u virkni, nevis kÄ `NULL`.  
                   TÄpÄ“c gadÄ«jumos, kad lauks tiek pÄrbaudÄ«ts uz `NULL`, var izmantot `NULLIF(lauks, '')`, lai panÄktu lÄ«dzÄ«gu uzvedÄ«bu.

---

###  ğŸ”’ UNIQUE
 - **Oracle**: `email VARCHAR2(100) UNIQUE`
 - **PostgreSQL**: `CONSTRAINT uniq_customer_email UNIQUE(email)`
 
**Paskaidrojums:** PostgreSQL atbalsta tieÅ¡i tÄdu paÅ¡u semantiku, kÄ Oracle, bet tika nolemts `UNIQUE CONSTRAINT` izveidot atseviÅ¡Ä·i,
                   jo tas dod lasÄmu un saprotamu vÄrdu, kas turpmÄk palÄ«dzÄ“s Ä“rtÄk ar to strÄdÄt.

---

###  ğŸ•’ Datumu lauku tips
 - **Oracle**: `created_date DATE DEFAULT SYSDATE`
 - **PostgreSQL**: `created_date TIMESTAMP DEFAULT LOCALTIMESTAMP`

**Paskaidrojums:** Oracle tips `DATE` tiek aizvietots ar `TIMESTAMP`.
                   Oracle tekoÅ¡Ä laika operators `SYSDATE` tiek aizvietots ar `LOCALTIMESTAMP`.

---

### âœ… Boolean lauku tips
 - **Oracle**: `is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0, 1))`
 - **PostgreSQL**: `is_active BOOLEAN DEFAULT TRUE`

**Paskaidrojums:** Oracle neatbalsta `BOOLEAN` tipu, bet PostgreSQL atbalsta.

---

### ğŸ”¢ Ciparu lauku tips
 - **Oracle**: `NUMBER`
 - **PostgreSQL**: `NUMERIC`

---


## ğŸ§© ProcedurÄlÄs loÄ£ikas migrÄcija

### ğŸ” IN/OUT
 - **Oracle**: `NorÄda pÄ“c parametra nosaukuma`
 - **PostgreSQL**: `NorÄda pirms parametra nosaukuma`

---

### AtgrieÅ¡anas operators
 - **Oracle**: `RETURN`
 - **PostgreSQL**: `RETURNS`

---

### Teksta pÄrbaude uz NULL
 - **Oracle**: `IF v_summary IS NULL THEN`
 - **PostgreSQL**: `IF v_summary = '' THEN`

**Paskaidrojums:** Oracle gadÄ«jumÄ tukÅ¡a virkne ('') tiek interpretÄ“ta kÄ NULL, tÄpÄ“c pietiek pÄrbaudÄ«t ar IS NULL.
                   SavukÄrt PostgreSQL tukÅ¡a virkne nav NULL, tÄ ir atseviÅ¡Ä·a vÄ“rtÄ«ba (''), tÄpÄ“c pÄrbaude jÄveic tieÅ¡i ar = ''.

---

### PÄreja uz jaunu rindu
 - **Oracle**: `CHR(10)`
 - **PostgreSQL**: `E'\n'`

**Paskaidrojums:** Abas datu bÄzes atbalsta ASCII koda izmantoÅ¡anu (CHR(10) â€” jaunas rindas simbols).
                   TaÄu PostgreSQL papildus piedÄvÄ E'' sintaksi, kur \n ir speciÄla â€œescapeâ€ secÄ«ba, kas apzÄ«mÄ“ jaunu rindu.

---

### ğŸ¯ Kursora tips 
 - **Oracle**: `SYS_REFCURSOR`
 - **PostgreSQL**: `REFCURSOR`

---

### ğŸ” SELECT INTO -> NOT EXISTS 
 - **Oracle**: 

 ```
 SELECT COUNT(*) INTO v_exists
 FROM customers
 WHERE customer_id = p_customer_id;

 IF v_exists = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Customer not found');
END IF;
```

 - **PostgreSQL**:

```
IF NOT EXISTS(
	SELECT 1 FROM customers WHERE customer_id = p_customer_id
) THEN
	RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P0001';
END IF;
```

**Paskaidrojums:** PostgreSQL atbalsta `NOT EXISTS/EXISTS` izmantoÅ¡anu tieÅ¡i IF kontekstÄ, kas padara kodu Ä«sÄku un saprotamÄku. Oracle Å¡Ädu iespÄ“ju nav.

---

### âš ï¸ KÄ¼Å«du izsaukums
 - **Oracle**: `RAISE_APPLICATION_ERROR(-20001, 'Customer not found');`
 - **PostgreSQL**: `RAISE EXCEPTION 'Customer not found' USING ERRCODE = 'P0001';`

**Paskaidrojums:** Oracle kÄ¼Å«du kodi (-20001 utt.) tiek aizstÄti ar PostgreSQL lietotÄja kÄ¼Å«du kodiem (P1000â€“P9999).
                   PostgreSQL gadÄ«jumÄ kÄ¼Å«das kods jÄnorÄda skaidri ar `USING ERRCODE`.

---

### ğŸ§  Dinamiskie SQL
 - **Oracle**: `UPDATE products SET price = :1 WHERE product_id = :2';`
 - **PostgreSQL**: `UPDATE products SET price = $1 WHERE product_id = $2`

**Paskaidrojums:** PostgreSQL lai apzÄ«mÄ“tu parametrus, divpunktu vietÄ izmanto dolÄrzÄ«mes.

---

### ğŸš€ Dinamiskie SQL palaiÅ¡ana
 - **Oracle**: `EXECUTE IMMEDIATE v_sql USING p_new_price, p_product_id;`
 - **PostgreSQL**: `EXECUTE v_sql USING p_new_price, p_product_id;`

**Paskaidrojums:** PostgreSQL neizmanto `IMMEDIATE`, vienkÄrÅ¡i EXECUTE.

---

### ğŸ”¢ Rindu skaita iegÅ«Å¡ana
 - **Oracle**: `SQL%ROWCOUNT`
 - **PostgreSQL**: `GET DIAGNOSTICS v_count = ROW_COUNT;`

**Paskaidrojums:** PostgreSQL ir komanda `GET DIAGNOSTICS` kura Ä¼auj dabÅ«t skarto rindu skaitu ar DML operÄcijÄm. 
                   `GET DIAGNOSTICS` â€” universÄls mehÄnisms, kurÅ¡ Ä¼auj dabÅ«t vairÄk informÄcijas, nekÄ vienkÄrÅ¡i rindu skaitu.
